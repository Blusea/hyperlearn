

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>hyperlearn.randomized.linalg &mdash; HyperLearn 1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> HyperLearn
          

          
          </a>

          
            
            
              <div class="version">
                0.0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../source/modules.html">hyperlearn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../base.html">hyperlearn.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../linalg.html">hyperlearn.linalg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html#contact">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">HyperLearn</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>hyperlearn.randomized.linalg</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for hyperlearn.randomized.linalg</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">linalg</span>
<span class="kn">from</span> <span class="nn">..numba.funcs</span> <span class="k">import</span> <span class="n">arange</span><span class="p">,</span> <span class="n">var</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..stats</span> <span class="k">import</span> <span class="n">corr</span><span class="p">,</span> <span class="n">corr_sum</span>
<span class="kn">from</span> <span class="nn">..linalg</span> <span class="k">import</span> <span class="n">transpose</span>
<span class="kn">from</span> <span class="nn">..random</span> <span class="k">import</span> <span class="n">normal</span><span class="p">,</span> <span class="n">choice</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="o">*</span>


<span class="c1">########################################################</span>
<span class="c1">## 1. ColumnSelect</span>
<span class="c1">## 2. Count Sketch (Fast JLT alternative)</span>
<span class="c1">## 3. Fast Count Sketch multiply</span>
<span class="c1">## 4. ColumnSelect Matrix Multiply (Nystrom Method)</span>


<span class="c1">###</span>
<div class="viewcode-block" id="select"><a class="viewcode-back" href="../../../source/hyperlearn.html#hyperlearn.randomized.linalg.select">[docs]</a><span class="k">def</span> <span class="nf">select</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;columns&quot;</span><span class="p">,</span> 
    <span class="n">duplicates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_oversamples</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects columns from the matrix X using many solvers. Also</span>
<span class="sd">    called ColumnSelect or LinearSelect, HyperLearn&#39;s select allows</span>
<span class="sd">    randomized algorithms to select important columns.</span>
<span class="sd">    [Added 30/11/18] [Edited 2/12/18 Added BSS sampling]</span>
<span class="sd">    [Edited 10/12/18 Fixed BSS Sampling]</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    X:              General Matrix.</span>
<span class="sd">    n_components:   How many columns you want.</span>
<span class="sd">    solver:         (euclidean, uniform, leverage, adaptive) Selects columns</span>
<span class="sd">                    based on separate squared norms of each property.</span>
<span class="sd">                    [NEW Adaptive]. Iteratively adds parts. (Most accuarate)</span>

<span class="sd">    output:         (columns, statistics, indices) Whether to output actual</span>
<span class="sd">                    columns or just indices of the selected columns.</span>
<span class="sd">                    Also can choose statistics to get norms only.</span>
<span class="sd">    duplicates:     If True, then leaves duplicates as is. If False,</span>
<span class="sd">                    uses sqrt(count) as a scaling factor.</span>
<span class="sd">    n_oversamples:  (klogk, 0) How many extra samples is taken.</span>
<span class="sd">                    Default = 0. Not much difference.</span>
<span class="sd">    axis:           (0, 1, 2) 0 is columns. 1 is rows. 2 means both.</span>
<span class="sd">    n_jobs:         Default = 1. Whether to use &gt;= 1 CPU.</span>

<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    (X*, indices) Depends on output option.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">n_components</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n_components</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span> <span class="ow">and</span> <span class="n">n_components</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">:</span> <span class="n">k</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">k</span>

    <span class="c1"># If adaptive</span>
    <span class="n">adaptive</span> <span class="o">=</span> <span class="p">(</span><span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;adaptive&quot;</span><span class="p">)</span>

    <span class="c1"># Oversample ratio. klogk allows (1+e)||X-X*|| error.</span>
    <span class="k">if</span> <span class="n">n_oversamples</span> <span class="o">==</span> <span class="s2">&quot;klogk&quot;</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_components</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">n_components</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_components</span><span class="p">)</span>

    <span class="n">n_components</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">n_components</span>

    <span class="c1"># rows and columns</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>   <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>           <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>

    <span class="c1"># Calculate row or column importance.</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;leverage&quot;</span> <span class="ow">or</span> <span class="n">adaptive</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">n_oversamples</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">row_norm</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col_norm</span><span class="p">(</span><span class="n">VT</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">n_oversamples</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">row_norm</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">n_oversamples</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">row_norm</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>   <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span>   <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>   <span class="n">row</span> <span class="o">=</span> <span class="n">row_norm</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span>   <span class="n">col</span> <span class="o">=</span> <span class="n">col_norm</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">r</span><span class="p">:</span>       <span class="n">row</span> <span class="o">=</span> <span class="n">proportion</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c</span><span class="p">:</span>       <span class="n">col</span> <span class="o">=</span> <span class="n">proportion</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s2">&quot;statistics&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>       <span class="k">return</span> <span class="n">col</span><span class="p">,</span> <span class="n">row</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>     <span class="k">return</span> <span class="n">col</span>
        <span class="k">else</span><span class="p">:</span>               <span class="k">return</span> <span class="n">row</span>

    <span class="c1"># Make a probability drawing distribution.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">adaptive</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">indicesN</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">row</span><span class="p">)</span>

            <span class="c1"># Use extra sqrt(count) scaling factor for repeated columns</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">duplicates</span><span class="p">:</span>
                <span class="n">indicesN</span><span class="p">,</span> <span class="n">countN</span> <span class="o">=</span> <span class="n">unique_int</span><span class="p">(</span><span class="n">indicesN</span><span class="p">,</span> <span class="n">return_counts</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">scalerN</span> <span class="o">=</span> <span class="n">countN</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">indicesN</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scalerN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">indicesN</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">scalerN</span> <span class="o">**=</span> <span class="mf">0.5</span>
            <span class="n">scalerN</span> <span class="o">=</span> <span class="n">scalerN</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">indicesP</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">col</span><span class="p">)</span>

            <span class="c1"># Use extra sqrt(count) scaling factor for repeated columns</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">duplicates</span><span class="p">:</span>
                <span class="n">indicesP</span><span class="p">,</span> <span class="n">countP</span> <span class="o">=</span> <span class="n">unique_int</span><span class="p">(</span><span class="n">indicesP</span><span class="p">,</span> <span class="n">return_counts</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">scalerP</span> <span class="o">=</span> <span class="n">countP</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="n">indicesP</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scalerP</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="n">indicesP</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">scalerP</span> <span class="o">**=</span> <span class="mf">0.5</span>

    <span class="c1"># Adaptive solver from Woodruff&#39;s 2014 Optimal CUR Decomp paper.</span>
    <span class="c1"># Changed and upgraded into incremental solver. (Approx 1+e||A-A*|| error)</span>
    <span class="k">if</span> <span class="n">adaptive</span> <span class="ow">and</span> <span class="n">c</span><span class="p">:</span>
        <span class="n">kk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Use Woodruff&#39;s CountSketch matrix to reduce space complexity.</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">sketch</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">kk</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">SX</span> <span class="o">=</span> <span class="n">sketch_multiply_left</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">kk</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span><span class="p">)</span>

        <span class="c1"># Only want top eigenvector</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="n">SX</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_oversamples</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">U_decision</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Find maximum column norm -&gt; determinstic algorithm</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">proportion</span><span class="p">(</span><span class="n">row_norm</span><span class="p">(</span><span class="n">V</span><span class="p">))</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">scalerP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">indicesP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">indicesP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">select</span>

        <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">norm</span><span class="p">[</span><span class="n">select</span><span class="p">]</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">scalerP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">C</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span><span class="n">select</span><span class="p">]</span><span class="o">*</span><span class="n">s</span>

        <span class="n">seen</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="c1"># Produce S*C, which is a smaller matrix</span>
            <span class="n">SC</span> <span class="o">=</span> <span class="n">sketch_multiply_left</span><span class="p">(</span><span class="n">C</span><span class="p">[:,:</span><span class="n">I</span><span class="p">],</span> <span class="n">S</span><span class="p">,</span> <span class="n">kk</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span><span class="p">)</span>

            <span class="c1"># Find projection residual</span>
            <span class="c1"># Notice left to right sometimes faster -&gt; so check.</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">SC</span><span class="p">)</span>
            <span class="n">left_to_right</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">SC</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">SX</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">left_to_right</span><span class="p">:</span>
                <span class="c1"># Better to do CC+ by itself.</span>
                <span class="n">CinvC</span> <span class="o">=</span> <span class="n">SC</span> <span class="o">@</span> <span class="n">inv</span>
                <span class="n">CinvC</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">CinvC</span><span class="o">.</span><span class="n">flat</span><span class="p">[::</span><span class="n">CinvC</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">col_norm</span><span class="p">(</span><span class="n">CinvC</span> <span class="o">@</span> <span class="n">SX</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">col_norm</span><span class="p">(</span><span class="n">SX</span> <span class="o">-</span>  <span class="p">(</span><span class="n">SC</span> <span class="o">@</span> <span class="p">(</span><span class="n">inv</span> <span class="o">@</span> <span class="n">SX</span><span class="p">))</span> <span class="p">)</span>

            <span class="c1"># Convert to probabilities</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">proportion</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
            <span class="n">indicesP</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">select</span>    
            
            <span class="c1"># Have to rescale old slcaers, and update new.</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">seen</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">seen</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">seen</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">old</span><span class="o">/</span><span class="n">new</span>
            <span class="n">C</span><span class="p">[:,:</span><span class="n">I</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span>
            <span class="n">scalerP</span><span class="p">[:</span><span class="n">I</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span>

            <span class="c1"># Update C</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">((</span><span class="n">norm</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">*</span> <span class="n">seen</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">C</span><span class="p">[:,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span><span class="n">select</span><span class="p">]</span><span class="o">*</span><span class="n">s</span>
            <span class="n">scalerP</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

    <span class="c1"># Return output</span>
    <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s2">&quot;columns&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">adaptive</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span><span class="n">indicesP</span><span class="p">]</span> <span class="o">*</span> <span class="n">scalerP</span>
            <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">indicesN</span><span class="p">]</span> <span class="o">*</span> <span class="n">scalerN</span>

        <span class="c1"># # Output columns if specified</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>       <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">R</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>     <span class="k">return</span> <span class="n">C</span>
        <span class="k">else</span><span class="p">:</span>               <span class="k">return</span> <span class="n">R</span>
    <span class="c1"># Or just output indices with scalers</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>       <span class="k">return</span> <span class="p">(</span><span class="n">indicesN</span><span class="p">,</span> <span class="n">scalerN</span><span class="p">),</span> <span class="p">(</span><span class="n">indicesP</span><span class="p">,</span> <span class="n">scalerP</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>     <span class="k">return</span> <span class="n">indicesP</span><span class="p">,</span> <span class="n">scalerP</span>
        <span class="k">else</span><span class="p">:</span>               <span class="k">return</span> <span class="n">indicesN</span><span class="p">,</span> <span class="n">scalerN</span></div>


<span class="c1">###</span>
<div class="viewcode-block" id="matmul"><a class="viewcode-back" href="../../../source/hyperlearn.html#hyperlearn.randomized.linalg.matmul">[docs]</a><span class="k">def</span> <span class="nf">matmul</span><span class="p">(</span>
    <span class="n">pattern</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
    <span class="n">n_oversamples</span> <span class="o">=</span> <span class="s2">&quot;klogk&quot;</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mirrors hyperlearn.linalg&#39;s matmul functionality, but extends it by</span>
<span class="sd">    using the randomized ColumnSelect algorithm. This can dramatically</span>
<span class="sd">    reduce compute time, but still allows good approximate guarantees.</span>
<span class="sd">    [Added 1/12/18]</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    pattern:        Can include: X.H @ X | X @ X.H</span>
<span class="sd">    X:              Compulsory left side matrix.</span>
<span class="sd">    n_components:   (int, float). Can be a ratio of total number of</span>
<span class="sd">                    columns or rows.</span>
<span class="sd">    solver:         (euclidean, uniform, leverage, adaptive) Selects columns</span>
<span class="sd">                    based on separate squared norms of each property.</span>
<span class="sd">    n_oversamples:  (klogk, 0, k) How many extra samples is taken.</span>
<span class="sd">                    Default = k*log2(k) which guarantees (1+e)||X-X*||</span>
<span class="sd">                    error.</span>
<span class="sd">    axis:           (0, 1). Can be 0 (columns) which reduces the total</span>
<span class="sd">                    dimensionality of the data or 1 (rows) which just</span>
<span class="sd">                    reduces the compute time of forming XTX or XXT.</span>
<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    out:            Special sketch matrix output according to pattern.</span>
<span class="sd">    indices:        Output the indices used in the sketching matrix.</span>
<span class="sd">    scaler:         Output the scaling factor by which the columns are</span>
<span class="sd">                    scaled by.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtypeX</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Use ColumnSelect to sketch the matrix:</span>
    <span class="n">indices</span><span class="p">,</span> <span class="n">scaler</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">n_oversamples</span> <span class="o">=</span> <span class="n">n_oversamples</span><span class="p">,</span> 
        <span class="n">duplicates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;indices&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Columns</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span><span class="n">indices</span><span class="p">]</span> <span class="o">*</span> <span class="n">scaler</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">*</span> <span class="n">scaler</span>
    
    <span class="k">return</span> <span class="n">linalg</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">A</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">scaler</span></div>


<span class="c1">########################################################</span>
<span class="c1">## 1. Randomized Projection onto orthogonal bases</span>
<span class="c1">## 2. SVD, eig, eigh</span>
<span class="c1">## 3. CUR decomposition</span>


<span class="c1">###</span>
<div class="viewcode-block" id="randomized_projection"><a class="viewcode-back" href="../../../source/hyperlearn.html#hyperlearn.randomized.linalg.randomized_projection">[docs]</a><span class="k">def</span> <span class="nf">randomized_projection</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;lu&#39;</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">symmetric</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Projects X onto some random eigenvectors, then using a special</span>
<span class="sd">    variant of Orthogonal Iteration, finds the closest orthogonal</span>
<span class="sd">    representation for X.</span>
<span class="sd">    [Added 25/11/18] [Edited 26/11/18 Overwriting all temp variables]</span>
<span class="sd">    [Edited 1/12/18 Added Eigh support]</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    X:              General Matrix.</span>
<span class="sd">    n_components:   How many eigenvectors you want.</span>
<span class="sd">    solver:         (auto, lu, qr, None) Default is LU Decomposition</span>
<span class="sd">    max_iter:       Default is 4 iterations.</span>
<span class="sd">    symmetric:      If symmetric, reduces computation time.</span>

<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    QR Decomposition of orthogonal matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_components</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_iter</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="c1"># From Modern Big Data Algorithms --&gt; seems like &lt;= 4 is enough.</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">6</span> <span class="k">if</span> <span class="n">n_components</span> <span class="o">&lt;</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">_min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">else</span> <span class="mi">5</span>

    <span class="c1"># Check n_components isn&#39;t too large</span>
    <span class="k">if</span> <span class="n">n_components</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">:</span> <span class="n">n_components</span> <span class="o">=</span> <span class="n">p</span>

    <span class="c1"># Notice overwriting doesn&#39;t matter since guaranteed to converge.</span>
    <span class="n">_solver</span> <span class="o">=</span>                       <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lu</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;qr&#39;</span><span class="p">:</span> <span class="n">_solver</span> <span class="o">=</span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
        <span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span> <span class="n">_solver</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">col_norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>

    <span class="k">if</span> <span class="n">symmetric</span><span class="p">:</span>
        <span class="c1"># # Get normal random numbers Q~N(0,1)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">n_components</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">/=</span> <span class="p">(</span><span class="n">row_norm</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1"># Normalize columns</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span>

        <span class="n">max_iter</span> <span class="o">*=</span> <span class="mf">1.5</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)</span>
        <span class="c1"># Cause symmetric, more stable, but needs more iterations.</span>

        <span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="s2">&quot;S @ Y&quot;</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">_solver</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="s2">&quot;S @ Y&quot;</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Get normal random numbers Q~N(0,1)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n_components</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">/=</span> <span class="n">col_norm</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="c1"># Normalize columns</span>

        <span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">Q</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">_solver</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="s2">&quot;X.H @ Y&quot;</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">_solver</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">Q</span>

    <span class="n">Q</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Q_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Q</span></div>


<span class="c1">###</span>
<div class="viewcode-block" id="svd"><a class="viewcode-back" href="../../../source/hyperlearn.html#hyperlearn.randomized.linalg.svd">[docs]</a><span class="nd">@process</span><span class="p">(</span><span class="n">memcheck</span> <span class="o">=</span> <span class="s2">&quot;truncated&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">svd</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;lu&#39;</span><span class="p">,</span> <span class="n">n_oversamples</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> 
    <span class="n">U_decision</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">conjugate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    HyperLearn&#39;s Fast Randomized SVD is approx 20 - 40 % faster than</span>
<span class="sd">    Sklearn&#39;s implementation depending on n_components and max_iter.</span>
<span class="sd">    [Added 27/11/18]</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    X:              General Matrix.</span>
<span class="sd">    n_components:   How many eigenvectors you want.</span>
<span class="sd">    max_iter:       Default is &#39;auto&#39;. Can be int.</span>
<span class="sd">    solver:         (auto, lu, qr, None) Default is LU Decomposition</span>
<span class="sd">    n_oversamples:  Samples more components than necessary. Used for</span>
<span class="sd">                    convergence purposes. More is slower, but allows</span>
<span class="sd">                    better eigenvectors. Default = 5</span>
<span class="sd">    U_decision:     Default = False. If True, uses max from U. If None. don&#39;t flip.</span>
<span class="sd">    n_jobs:         Whether to use more &gt;= 1 CPU</span>
<span class="sd">    conjugate:      Whether to inplace conjugate but inplace return original.</span>

<span class="sd">    Returns</span>
<span class="sd">    -----------    </span>
<span class="sd">    U:              Orthogonal Left Eigenvectors</span>
<span class="sd">    S:              Descending Singular Values</span>
<span class="sd">    VT:             Orthogonal Right Eigenvectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">ifTranspose</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">ifTranspose</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="n">Q</span> <span class="o">=</span> <span class="n">randomized_projection</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">+</span> <span class="n">n_oversamples</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">)</span>

    <span class="n">B</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">X</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">U_decision</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">B</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:</span><span class="n">n_components</span><span class="p">]</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">@</span> <span class="n">U</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_components</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ifTranspose</span><span class="p">:</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">VT</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="p">),</span> <span class="n">transpose</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">conjugate</span><span class="p">:</span>
            <span class="n">transpose</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_components</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">VT</span> <span class="o">=</span> <span class="n">VT</span><span class="p">[:</span><span class="n">n_components</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># flip signs</span>
    <span class="n">svd_flip</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">VT</span><span class="p">,</span> <span class="n">U_decision</span> <span class="o">=</span> <span class="n">ifTranspose</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">VT</span></div>


<span class="c1">###</span>
<div class="viewcode-block" id="pinv"><a class="viewcode-back" href="../../../source/hyperlearn.html#hyperlearn.randomized.linalg.pinv">[docs]</a><span class="nd">@process</span><span class="p">(</span><span class="n">memcheck</span> <span class="o">=</span> <span class="s2">&quot;same&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;SATAX&#39;</span><span class="p">,</span> 
    <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">conjugate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">converge</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the Pseudoinverse of the matrix X using randomizedSVD.</span>
<span class="sd">    Extremely fast. If n_components = &quot;auto&quot;, will get the top sqrt(p)+1</span>
<span class="sd">    singular vectors.</span>
<span class="sd">    [Added 30/11/18] [Edited 14/12/18 Added Newton Schulz and 2016 Gower&#39;s</span>
<span class="sd">    Linearly Convergent Randomized Pseudoinverse - R. M. Gower and Peter </span>
<span class="sd">    Richtarik. &quot;Linearly Convergent Randomized Iterative Methods for </span>
<span class="sd">    Computing the Pseudoinverse&quot;, arXiv:1612.06255]</span>
<span class="sd">    [16/12/18 Default changed to SKETCH (Newton with Sketching)]</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    X:              General matrix X.</span>
<span class="sd">    alpha :         Ridge alpha regularization parameter. Default 1e-6</span>
<span class="sd">    n_components:   Default = auto. Provide less to speed things up.</span>
<span class="sd">    max_iter:       Default is &#39;auto&#39;. Can be int.</span>
<span class="sd">    solver:         (auto, satax, newton, sketch, lu, qr, None) Default is SKETCH.</span>
<span class="sd">                    SATAX is from Gower&#39;s 2016 paper. (lu, qr and None) use 2011</span>
<span class="sd">                    Halko&#39;s Randomized Range Finder. Newton is Newton Schulz solver.</span>
<span class="sd">                    SKETCH is Newton + sketching.</span>
<span class="sd">    converge:       Default = True. If True, uses a newly discovered approach inspired</span>
<span class="sd">                    from Newton Schulz (inv -= 2*inv*X*inv)</span>
<span class="sd">    n_jobs:         Whether to use more &gt;= 1 CPU</span>
<span class="sd">    conjugate:      Whether to inplace conjugate but inplace return original.</span>

<span class="sd">    Returns</span>
<span class="sd">    -----------    </span>
<span class="sd">    pinv(X) :       Randomized Pseudoinverse of X. Approximately allows</span>
<span class="sd">                    pinv(X) @ X = I. Not exact.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">n_components</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
        <span class="n">n_components</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span> <span class="k">if</span> <span class="n">n_components</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="k">else</span> <span class="n">p</span>

    <span class="c1"># Gower&#39;s SATAX solver. Use&#39;s sketch and solve paradigm.</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;satax&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_iter</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="c1"># No need to do a lot of iterations. But, can provide stability.</span>
            <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">inv</span> <span class="o">=</span> <span class="n">_min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">row_norm</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># Tried just selecting via leverage scores, uniform etc. Sketch is best.</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">sketch</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="n">invS</span> <span class="o">=</span> <span class="n">sketch_multiply</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">S</span>

        <span class="n">BT</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">@</span> <span class="n">invS</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">BT</span> <span class="o">@</span> <span class="n">X</span>
        <span class="n">CCT</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="s2">&quot;X @ X.H&quot;</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
        <span class="n">invCCT</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">pinvh</span><span class="p">(</span><span class="n">CCT</span><span class="p">,</span> <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">inv</span> <span class="o">-</span> <span class="n">BT</span>
            <span class="n">inv</span> <span class="o">-=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">invCCT</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>


    <span class="c1"># Newton Schulz solver. Needs quite a lot of iterations</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;newton&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_iter</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">10</span>
        
        <span class="n">inv</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">frobenius_norm</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>

        <span class="c1"># Check X+ (2I - XX+)</span>
        <span class="n">left_to_right</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">inv</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left_to_right</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">inv</span><span class="p">)</span>
                <span class="n">inv</span> <span class="o">*=</span> <span class="mi">2</span>
                <span class="n">inv</span> <span class="o">-=</span> <span class="n">diff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Xinv</span> <span class="o">=</span> <span class="n">X</span> <span class="o">@</span> <span class="n">inv</span>
                <span class="n">Xinv</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">Xinv</span><span class="o">.</span><span class="n">flat</span><span class="p">[::</span><span class="n">Xinv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span>
                <span class="n">inv</span> <span class="o">=</span> <span class="n">inv</span> <span class="o">@</span> <span class="n">Xinv</span>


    <span class="c1"># Newton Schulz solver with sketching. Using too many iterations</span>
    <span class="c1"># causes errors to actually explode. So, 1 iteration is OK.</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;sketch&quot;</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">sketch</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">SX</span> <span class="o">=</span> <span class="n">sketch_multiply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="n">inv</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">frobenius_norm</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>

        <span class="n">S_first</span> <span class="o">=</span> <span class="n">sketch</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="n">S_second</span> <span class="o">=</span> <span class="n">sketch</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="n">S_third</span> <span class="o">=</span> <span class="n">sketch</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># X+S * SX</span>
        <span class="n">invS</span> <span class="o">=</span> <span class="n">sketch_multiply</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">S_first</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>
        <span class="n">invX</span> <span class="o">=</span> <span class="n">invS</span> <span class="o">@</span> <span class="n">SX</span>

        <span class="c1"># (X+S * SX)S</span>
        <span class="n">invXS</span> <span class="o">=</span> <span class="n">sketch_multiply</span><span class="p">(</span><span class="n">invX</span><span class="p">,</span> <span class="n">S_second</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">)</span>

        <span class="c1"># (X+S * SX)S * SX+</span>
        <span class="n">Sinv</span> <span class="o">=</span> <span class="n">sketch_multiply</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">S_third</span><span class="p">,</span> <span class="n">n_components</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="n">inv</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="n">inv</span> <span class="o">-=</span> <span class="n">invXS</span> <span class="o">@</span> <span class="n">Sinv</span>


    <span class="c1"># Else, use Halko&#39;s Randomized Range Finder for SVD. Least accurate.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_components</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;n_components &gt;= </span><span class="si">{n_components}</span><span class="s2"> will be slow. Consider full pinv or pinvc&quot;</span><span class="p">)</span>

        <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span>
                    <span class="n">X</span><span class="p">,</span> <span class="n">U_decision</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span><span class="p">,</span>
                    <span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">conjugate</span> <span class="o">=</span> <span class="n">conjugate</span><span class="p">)</span>

        <span class="n">U</span><span class="p">,</span> <span class="n">_S</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">svd_condition</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">VT</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">VT</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">_S</span><span class="p">)</span>   <span class="o">@</span> <span class="n">transpose</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Apply 1 extra iteration of Newton Schluz to allow convergence.</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">!=</span> <span class="s2">&quot;satax&quot;</span> <span class="ow">and</span> <span class="n">converge</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">inv</span><span class="p">)</span>
        <span class="n">inv</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="n">inv</span> <span class="o">-=</span> <span class="n">diff</span>
    <span class="k">return</span> <span class="n">inv</span></div>


<span class="c1">###</span>
<div class="viewcode-block" id="eig"><a class="viewcode-back" href="../../../source/hyperlearn.html#hyperlearn.randomized.linalg.eig">[docs]</a><span class="nd">@process</span><span class="p">(</span><span class="n">memcheck</span> <span class="o">=</span> <span class="s2">&quot;minimum&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">eig</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;lu&#39;</span><span class="p">,</span> 
    <span class="n">n_oversamples</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">conjugate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">U_decision</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    HyperLearn&#39;s Fast Randomized Eigendecomposition is approx 20 - 40 % faster than</span>
<span class="sd">    Sklearn&#39;s implementation depending on n_components and max_iter.</span>
<span class="sd">    [Added 27/11/18] [Edited 12/12/18 Added U_decision]</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    X:              General Matrix.</span>
<span class="sd">    n_components:   How many eigenvectors you want.</span>
<span class="sd">    max_iter:       Default is &#39;auto&#39;. Can be int.</span>
<span class="sd">    solver:         (auto, lu, qr, None) Default is LU Decomposition</span>
<span class="sd">    n_oversamples:  Samples more components than necessary. Used for</span>
<span class="sd">                    convergence purposes. More is slower, but allows</span>
<span class="sd">                    better eigenvectors. Default = 5</span>
<span class="sd">    conjugate:      Whether to inplace conjugate but inplace return original.</span>
<span class="sd">    n_jobs:         Whether to use more &gt;= 1 CPU</span>
<span class="sd">    U_decision:     (False, None)</span>

<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    W:              Eigenvalues</span>
<span class="sd">    V:              Eigenvectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">ifTranspose</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">ifTranspose</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="n">Q</span> <span class="o">=</span> <span class="n">randomized_projection</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">+</span> <span class="n">n_oversamples</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">X</span>


    <span class="k">if</span> <span class="n">ifTranspose</span><span class="p">:</span>
        <span class="c1"># use SVD instead</span>
        <span class="n">V</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">U_decision</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:</span><span class="n">n_components</span><span class="p">]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">@</span> <span class="n">V</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_components</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">conjugate</span><span class="p">:</span>
            <span class="n">transpose</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="p">);</span>
        <span class="n">W</span> <span class="o">**=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">U_decision</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:</span><span class="n">n_components</span><span class="p">]</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,:</span><span class="n">n_components</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">B</span>

    <span class="c1"># Flip signs</span>
    <span class="n">svd_flip</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">U_decision</span> <span class="o">=</span> <span class="n">U_decision</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">V</span></div>


<span class="c1">###</span>
<div class="viewcode-block" id="eigh"><a class="viewcode-back" href="../../../source/hyperlearn.html#hyperlearn.randomized.linalg.eigh">[docs]</a><span class="nd">@process</span><span class="p">(</span><span class="n">square</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">memcheck</span> <span class="o">=</span> <span class="s2">&quot;minimum&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">eigh</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">solver</span> <span class="o">=</span> <span class="s1">&#39;lu&#39;</span><span class="p">,</span> 
    <span class="n">n_oversamples</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">conjugate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    HyperLearn&#39;s Fast Randomized Hermitian Eigendecomposition uses</span>
<span class="sd">    QR Orthogonal Iteration. </span>
<span class="sd">    [Added 27/11/18]</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    X:              General Matrix.</span>
<span class="sd">    n_components:   How many eigenvectors you want.</span>
<span class="sd">    max_iter:       Default is &#39;auto&#39;. Can be int.</span>
<span class="sd">    solver:         (auto, lu, qr, None) Default is LU Decomposition</span>
<span class="sd">    n_oversamples:  Samples more components than necessary. Used for</span>
<span class="sd">                    convergence purposes. More is slower, but allows</span>
<span class="sd">                    better eigenvectors. Default = 5</span>
<span class="sd">    conjugate:      Whether to inplace conjugate but inplace return original.</span>
<span class="sd">    n_jobs:         Whether to use more &gt;= 1 CPU</span>

<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    W:              Eigenvalues</span>
<span class="sd">    V:              Eigenvectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">randomized_projection</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">+</span> <span class="n">n_oversamples</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">symmetric</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="n">B</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="s2">&quot;S @ Y&quot;</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">W</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">U_decision</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:</span><span class="n">n_components</span><span class="p">]</span><span class="o">**</span><span class="mf">0.5</span>

    <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,:</span><span class="n">n_components</span><span class="p">]</span>
    <span class="c1"># Flip signs</span>
    <span class="n">svd_flip</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">U_decision</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">V</span></div>


<span class="c1">###</span>
<div class="viewcode-block" id="qr"><a class="viewcode-back" href="../../../source/hyperlearn.html#hyperlearn.randomized.linalg.qr">[docs]</a><span class="nd">@process</span><span class="p">(</span><span class="n">memcheck</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;X&quot;</span><span class="p">:</span><span class="s2">&quot;truncated&quot;</span><span class="p">,</span><span class="s2">&quot;Q_only&quot;</span><span class="p">:</span><span class="s2">&quot;truncated&quot;</span><span class="p">,</span><span class="s2">&quot;R_only&quot;</span><span class="p">:</span><span class="s2">&quot;truncated&quot;</span><span class="p">})</span>
<span class="k">def</span> <span class="nf">qr</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Q_only</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">R_only</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_components</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> 
    <span class="n">solver</span> <span class="o">=</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">n_oversamples</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Approximate QR Decomposition using the Gram Schmidt Process. Not very</span>
<span class="sd">    accurate, but uses Euclidean Norm sampling from the ColumnSelect algo</span>
<span class="sd">    to appropriately select the first columns to orthogonalise. You can</span>
<span class="sd">    also set solver to &quot;variance&quot;, &quot;correlation&quot; or &quot;euclidean&quot;.</span>
<span class="sd">    [Added 8/12/18] [Edited 12/12/18 Uses argpartititon]</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    X:              General Matrix.</span>
<span class="sd">    y:              Optional. Used for &quot;correlation&quot; solver.</span>
<span class="sd">    n_components:   How many columns to orthogonalise. Default = 2</span>
<span class="sd">    solver:         (euclidean, variance, correlation) Which method</span>
<span class="sd">                    to choose columns. Default = euclidean.</span>
<span class="sd">    n_oversamples:  Samples more components than necessary. Used for</span>
<span class="sd">                    convergence purposes. More is slower, but allows</span>
<span class="sd">                    better eigenvectors. Default = 5</span>
<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    (Q,R) or (Q) or (R) depends on option Q_only or R_only</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">n_components</span> <span class="o">+</span> <span class="n">n_oversamples</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">:</span> <span class="n">k</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">kk</span> <span class="o">=</span> <span class="n">k</span><span class="o">*-</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;correlation&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">corr_sum</span><span class="p">(</span> <span class="n">corr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">corr</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span> <span class="n">C</span><span class="p">,</span> <span class="n">k</span> <span class="p">)[:</span><span class="n">k</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;variance&quot;</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span> <span class="n">var</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">kk</span><span class="p">)[</span><span class="n">kk</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">(</span> <span class="n">col_norm</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">kk</span><span class="p">)[</span><span class="n">kk</span><span class="p">:]</span>

    <span class="c1"># Gram Schmidt process</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">gram_schmidt</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Q_only</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># X = QR -&gt; QT X = QT Q R -&gt; QT X = R</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">@</span> <span class="n">X</span>
    <span class="k">if</span> <span class="n">R_only</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">R</span>
    <span class="k">return</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Daniel Han-Chen

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>